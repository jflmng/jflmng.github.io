<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Swarm Commander: Gold</title>
    <style>
        body { 
            margin: 0; overflow: hidden; background: #080808; 
            font-family: 'Segoe UI', 'Courier New', monospace; 
            touch-action: none; -webkit-user-select: none; user-select: none;
        }
        canvas { display: block; width: 100%; height: 100%; }
        
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; }

        /* HUD Elements */
        #stats {
            position: absolute; top: 20px; left: 20px; 
            background: rgba(5, 5, 10, 0.85); 
            padding: 12px 18px; border-radius: 4px; 
            border-left: 3px solid #00d2ff; color: #fff; font-size: 0.85rem;
            box-shadow: 0 0 15px rgba(0, 210, 255, 0.15);
            transform-origin: top left;
            transition: opacity 0.5s;
        }
        .row { display: flex; justify-content: space-between; margin-bottom: 4px; min-width: 140px; color: #889; }
        .val { color: #fff; font-weight: bold; }

        #progress-container { position: absolute; top: 0; left: 0; width: 100%; height: 4px; background: #222; }
        #progress-fill { height: 100%; background: #00d2ff; width: 0%; box-shadow: 0 0 15px #00d2ff; }

        #boss-hud {
            position: absolute; top: 60px; left: 50%; transform: translateX(-50%);
            width: 60%; max-width: 600px; display: none;
        }
        .boss-bar-frame { width: 100%; height: 16px; background: #111; border: 2px solid #555; margin-top: 4px; }
        #boss-health { width: 100%; height: 100%; background: #d32f2f; transition: width 0.05s; }
        #boss-label { text-align: center; color: #ef5350; font-weight: 800; letter-spacing: 3px; font-size: 0.8rem; text-shadow: 0 0 5px #b71c1c; }

        /* SCREENS (Start & Game Over) */
        .screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0, 5, 10, 0.9);
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            pointer-events: auto; /* Allow clicking */
            z-index: 10;
        }
        
        h1 { 
            font-size: 3.5rem; margin: 0 0 20px 0; color: white; letter-spacing: -2px; 
            text-shadow: 0 0 30px rgba(0, 210, 255, 0.6); 
            text-align: center; line-height: 1;
        }
        
        .instructions {
            color: #aaa; font-size: 1.1rem; max-width: 500px; text-align: center; line-height: 1.6; margin-bottom: 40px;
        }
        
        .key-item { display: inline-block; margin: 0 10px; }
        .key-highlight { color: #00d2ff; font-weight: bold; }
        .danger { color: #ff9800; font-weight: bold; }
        
        button {
            background: transparent; border: 2px solid #00d2ff; color: #00d2ff;
            padding: 15px 40px; font-size: 1.2rem; font-family: inherit; font-weight: bold;
            cursor: pointer; letter-spacing: 2px; transition: all 0.2s;
            text-transform: uppercase;
            box-shadow: 0 0 15px rgba(0, 210, 255, 0.2);
        }
        button:hover { background: #00d2ff; color: #000; box-shadow: 0 0 30px rgba(0, 210, 255, 0.6); }
        
        #game-over-screen { display: none; }

        /* Mobile Adjustments */
        @media (max-width: 600px) {
            #stats { transform: scale(0.8); top: 10px; left: 10px; }
            h1 { font-size: 2.5rem; }
            .instructions { font-size: 0.9rem; width: 90%; }
            button { padding: 12px 30px; font-size: 1rem; }
        }
    </style>
</head>
<body>

<div id="ui-layer">
    <div id="progress-container"><div id="progress-fill"></div></div>
    
    <div id="stats">
        <div class="row"><span>UNITS</span> <span id="count" class="val">0</span></div>
        <div class="row"><span>WAVE</span> <span id="wave" class="val">1</span></div>
        <div class="row"><span>HAZARD</span> <span id="haz-val" class="val">0.1%</span></div>
    </div>

    <div id="boss-hud">
        <div id="boss-label">⚠ CAPITAL SHIP ⚠</div>
        <div class="boss-bar-frame"><div id="boss-health"></div></div>
    </div>

    <div id="start-screen" class="screen">
        <h1>SWARM<br>COMMANDER</h1>
        <div class="instructions">
            <div class="key-item"><span class="key-highlight">DRAG</span> to Move & Fire</div>
            <br><br>
            Collect <span style="color:#00e676">Green Orbs</span> to grow.<br>
            Destroy <span style="color:#ff1744">Red Enemies</span>.<br>
            Avoid <span class="danger">Orange Interceptors</span>.
        </div>
        <button id="btn-start">INITIALIZE SYSTEM</button>
    </div>

    <div id="game-over-screen" class="screen">
        <h1 style="color: #ff1744; text-shadow: 0 0 30px rgba(255, 23, 68, 0.6);">SIGNAL LOST</h1>
        <div class="instructions">
            The swarm has been neutralized.<br>
            Sector <span id="final-wave" class="key-highlight">1</span> reached.
        </div>
        <button id="btn-restart">REBOOT SYSTEM</button>
    </div>
</div>

<canvas id="gameCanvas"></canvas>

<script>
    const CONFIG = {
        droneCount: 12,
        maxSpeed: 9.0,
        maxForce: 0.25,
        separationDist: 22,
        scrollSpeed: 4.2,
        fireRate: 11,
        damage: 8,
        bulletSpeed: 16,
        bossInterval: 14000, 
        minGameWidth: 1000
    };

    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    
    // State
    let width, height, scaleFactor;
    let mouse = { x: 0, y: 0, down: false };
    
    let game = {
        dist: 0,
        wave: 1,
        difficulty: 1.0,
        state: 'START', // START, SCROLLING, BOSS, GAMEOVER
        shake: 0,
        hazardRate: 0 
    };

    let drones = [];
    let bullets = []; 
    let eBullets = []; 
    let enemies = [];
    let powerups = [];
    let particles = [];
    let boss = null;

    const dist = (a, b) => Math.hypot(a.x - b.x, a.y - b.y);
    const rand = (min, max) => Math.random() * (max - min) + min;

    // --- SCALING ---
    function resize() {
        let realWidth = window.innerWidth;
        let realHeight = window.innerHeight;
        let aspect = realWidth / realHeight;

        if (realWidth < CONFIG.minGameWidth) {
            width = CONFIG.minGameWidth;
            height = width / aspect;
        } else {
            width = realWidth;
            height = realHeight;
        }

        canvas.width = width;
        canvas.height = height;
        scaleFactor = width / realWidth;

        if(mouse.x === 0) { mouse.x = width/2; mouse.y = height/2; }
    }

    // --- FX ---
    class Particle {
        constructor(x, y, color, speedVal=4, size=3, lifeDecay=0.04) {
            this.x = x; this.y = y;
            let a = Math.random() * Math.PI * 2;
            let s = Math.random() * speedVal + 1;
            this.vx = Math.cos(a) * s;
            this.vy = Math.sin(a) * s;
            this.life = 1.0;
            this.color = color;
            this.size = size;
            this.lifeDecay = lifeDecay;
        }
        update() {
            // Only scroll particles if game is scrolling
            let scroll = (game.state === 'SCROLLING' || game.state === 'BOSS') ? CONFIG.scrollSpeed : 0;
            this.x += this.vx - scroll; 
            this.y += this.vy;
            this.life -= this.lifeDecay;
        }
        draw() {
            ctx.globalAlpha = Math.max(0, this.life);
            ctx.fillStyle = this.color;
            ctx.fillRect(this.x, this.y, this.size, this.size);
            ctx.globalAlpha = 1.0;
        }
    }

    function explode(x, y, color, count=8, speed=4, size=3, lifeDecay=0.04) {
        for(let i=0; i<count; i++) particles.push(new Particle(x, y, color, speed, size, lifeDecay));
    }

    // --- Classes ---
    class Drone {
        constructor(x, y) {
            this.pos = { x: x, y: y };
            this.vel = { x: 0, y: 0 };
            this.acc = { x: 0, y: 0 };
            this.radius = 5;
            this.cooldown = rand(0, 10);
        }
        applyForce(x, y) { this.acc.x += x; this.acc.y += y; }
        update(swarm) {
            let dx = mouse.x - this.pos.x;
            let dy = mouse.y - this.pos.y;
            let d = Math.hypot(dx, dy);
            let tx = 0, ty = 0;
            if (d > 0) {
                let speed = (d < 100) ? (d/100)*CONFIG.maxSpeed : CONFIG.maxSpeed;
                tx = (dx/d) * speed; ty = (dy/d) * speed;
            }
            let steerX = tx - this.vel.x; let steerY = ty - this.vel.y;
            let sepX = 0, sepY = 0, count = 0;
            for (let other of swarm) {
                if (other === this) continue;
                let distance = dist(this.pos, other.pos);
                if (distance < CONFIG.separationDist && distance > 0) {
                    let pushX = this.pos.x - other.pos.x; let pushY = this.pos.y - other.pos.y;
                    pushX /= distance; pushY /= distance; 
                    sepX += pushX; sepY += pushY; count++;
                }
            }
            if (count > 0) {
                sepX = (sepX/count) * CONFIG.maxSpeed; sepY = (sepY/count) * CONFIG.maxSpeed;
                sepX -= this.vel.x; sepY -= this.vel.y;
            }
            this.applyForce(steerX, steerY);
            this.applyForce(sepX * 2.5, sepY * 2.5);
            let force = Math.hypot(this.acc.x, this.acc.y);
            if (force > CONFIG.maxForce) {
                this.acc.x = (this.acc.x/force)*CONFIG.maxForce;
                this.acc.y = (this.acc.y/force)*CONFIG.maxForce;
            }
            this.vel.x += this.acc.x; this.vel.y += this.acc.y;
            this.pos.x += this.vel.x; this.pos.y += this.vel.y;
            this.acc.x = 0; this.acc.y = 0;
            this.cooldown--;
            // Only fire if game is active
            if (game.state !== 'START' && game.state !== 'GAMEOVER' && this.cooldown <= 0 && mouse.down) this.fire();
        }
        fire() {
            const engageDist = width * 0.65; 
            let target = null; let minD = engageDist;
            if (boss) {
                let d = dist(this.pos, boss);
                if (d < minD) target = boss;
            } 
            if (!target) {
                enemies.forEach(e => {
                    if (e.invulnerable) return; 
                    let d = dist(this.pos, e);
                    if(d < minD && e.x < width && e.x > this.pos.x - 50) { 
                        minD = d; target = e; 
                    }
                });
            }
            if (target) {
                let angle = Math.atan2(target.y - this.pos.y, target.x - this.pos.x);
                angle += (Math.random()-0.5)*0.12; 
                let lifeFrames = engageDist / CONFIG.bulletSpeed;
                bullets.push({
                    x: this.pos.x, y: this.pos.y,
                    vx: Math.cos(angle)*CONFIG.bulletSpeed, 
                    vy: Math.sin(angle)*CONFIG.bulletSpeed,
                    life: lifeFrames, maxLife: lifeFrames
                });
                this.cooldown = CONFIG.fireRate + rand(0,3);
            }
        }
        draw() {
            ctx.beginPath(); ctx.arc(this.pos.x, this.pos.y, this.radius, 0, Math.PI*2);
            ctx.fillStyle = '#00d2ff'; ctx.fill();
        }
    }

    class Enemy {
        constructor(type) {
            this.type = type;
            this.x = width + rand(50, 200);
            this.y = rand(50, height-50);
            this.marked = false;
            this.invulnerable = false;
            let diff = game.difficulty;
            if (type === 'standard') {
                this.hp = 30 * diff; this.maxHp = this.hp;
                this.speed = CONFIG.scrollSpeed; this.radius = 15; this.color = '#e53935'; 
            } else if (type === 'interceptor') {
                this.hp = 9999; this.invulnerable = true;
                this.speed = CONFIG.scrollSpeed * 1.8; this.radius = 14; 
                this.color = '#ff9800'; 
            }
        }
        update() {
            this.x -= this.speed;
            if (this.type === 'standard') {
                this.y += Math.sin(this.x * 0.01) * 2.5;
            } else {
                let dy = mouse.y - this.y; this.y += Math.sign(dy) * 1.8; 
            }
        }
        draw() {
            ctx.beginPath();
            if (this.type === 'standard') {
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI*2);
                ctx.fillStyle = this.color; ctx.fill();
            } else {
                ctx.moveTo(this.x+15, this.y); ctx.lineTo(this.x, this.y-15); 
                ctx.lineTo(this.x-15, this.y); ctx.lineTo(this.x, this.y+15);
                ctx.fillStyle = this.color; ctx.fill();
                ctx.shadowBlur = 15; ctx.shadowColor = '#ffc107'; 
                ctx.strokeStyle = '#ffa726'; ctx.lineWidth = 2; ctx.stroke(); 
                ctx.shadowBlur = 0; 
            }
            if (!this.invulnerable && this.hp < this.maxHp) {
                ctx.fillStyle = 'white'; ctx.fillRect(this.x-12, this.y - this.radius - 8, 24 * (this.hp/this.maxHp), 3);
            }
        }
    }

    class Boss {
        constructor() {
            this.x = width + 250;
            this.y = height / 2;
            this.radius = 75;
            this.maxHp = 5000 + (Math.pow(game.wave, 1.2) * 3000);
            this.hp = this.maxHp;
            this.timer = 0;
            this.charge = 0;
            this.patternTimer = 0;
            this.currentPattern = 0; 
        }
        update() {
            if (this.x > width - 250) { this.x -= 1.5; return; }
            this.timer++;
            this.y = (height/2) + Math.sin(this.timer * 0.015) * 220;
            
            let interval = 65;
            let cycle = this.timer % interval;
            this.charge = (cycle > interval - 20) ? (cycle - (interval-20))/20 : 0;

            if (cycle === 0) this.fire();

            this.patternTimer++;
            if (this.patternTimer % (interval * 4) === 0) { 
                this.currentPattern = (this.currentPattern + 1) % 3;
            }
        }
        fire() {
            let aim = Math.atan2(mouse.y - this.y, mouse.x - this.x);
            const bulletSpeed = 8;
            const spreadAngle = 0.15;

            switch (this.currentPattern) {
                case 0: // Spread
                    for(let i=-2; i<=2; i++) {
                        eBullets.push({
                            x: this.x, y: this.y,
                            vx: Math.cos(aim + i*spreadAngle) * bulletSpeed, 
                            vy: Math.sin(aim + i*spreadAngle) * bulletSpeed,
                            radius: 7, color: '#ff1744'
                        });
                    }
                    break;
                case 1: // Burst
                    for(let i=0; i<5; i++) { 
                        eBullets.push({
                            x: this.x, y: this.y,
                            vx: Math.cos(aim + rand(-0.05, 0.05)) * bulletSpeed * 1.2, 
                            vy: Math.sin(aim + rand(-0.05, 0.05)) * bulletSpeed * 1.2,
                            radius: 7, color: '#ff1744'
                        });
                    }
                    break;
                case 2: // Spiral
                    let spiralAngle = (this.timer * 0.1) % (Math.PI * 2);
                    for(let i=0; i<4; i++) { 
                        eBullets.push({
                            x: this.x, y: this.y,
                            vx: Math.cos(spiralAngle + i * (Math.PI/2)) * bulletSpeed, 
                            vy: Math.sin(spiralAngle + i * (Math.PI/2)) * bulletSpeed,
                            radius: 7, color: '#ff1744'
                        });
                    }
                    break;
            }
            this.x += 5; 
        }
        draw() {
            ctx.save();
            ctx.shadowBlur = 20; ctx.shadowColor = '#b71c1c';
            ctx.fillStyle = '#212121'; ctx.beginPath(); ctx.arc(this.x, this.y, this.radius, 0, Math.PI*2); ctx.fill();
            ctx.shadowColor = 'white';
            ctx.shadowBlur = this.charge * 50;
            ctx.fillStyle = `rgba(255, ${23 + this.charge*230}, ${68 + this.charge*180}, 1)`; 
            ctx.beginPath(); ctx.arc(this.x, this.y, this.radius * 0.4, 0, Math.PI*2); ctx.fill();
            ctx.strokeStyle = '#d32f2f'; ctx.lineWidth = 6; ctx.stroke();
            ctx.restore();
        }
    }

    // --- Systems ---
    function spawnSystem() {
        if (game.state !== 'SCROLLING') return;
        
        let stress = Math.min(drones.length / 10, 2); 
        let stdChance = 0.015 * game.difficulty * stress;
        if (Math.random() < stdChance) enemies.push(new Enemy('standard'));

        let interceptorBase = 0.0005 + ((game.wave - 1) * 0.002);
        let interceptorChance = Math.min(interceptorBase, 0.008);
        game.hazardRate = (interceptorChance * 100).toFixed(2);
        if (Math.random() < interceptorChance) enemies.push(new Enemy('interceptor'));

        if (Math.random() < 0.02) powerups.push({ x: width+50, y: rand(50, height-50), radius: 8, active: true });

        if (game.dist >= CONFIG.bossInterval) startBoss();
    }

    function startBoss() {
        game.state = 'BOSS';
        document.getElementById('boss-hud').style.display = 'block';
        document.getElementById('progress-fill').style.width = '100%';
        enemies.forEach(e => explode(e.x, e.y, e.color));
        enemies = [];
        boss = new Boss();
    }

    function gameOver() {
        game.state = 'GAMEOVER';
        document.getElementById('final-wave').innerText = game.wave;
        document.getElementById('game-over-screen').style.display = 'flex';
    }

    function resetGame() {
        game.wave = 1;
        game.difficulty = 1.0;
        game.dist = 0;
        game.state = 'SCROLLING';
        drones = [];
        enemies = [];
        bullets = [];
        eBullets = [];
        powerups = [];
        particles = [];
        boss = null;
        document.getElementById('boss-hud').style.display = 'none';
        document.getElementById('progress-fill').style.width = '0%';
        
        // Initial Swarm
        for(let i=0; i<CONFIG.droneCount; i++) drones.push(new Drone(width/2, height/2));
    }

    function checkCollisions() {
        bullets.forEach(b => {
            if(boss && dist(b, boss) < boss.radius) {
                boss.hp -= CONFIG.damage; b.life = 0; 
                explode(b.x, b.y, '#ff8a80', 5, 8, 4, 0.03);
            }
            enemies.forEach(e => {
                let hitR = e.invulnerable ? 15 : 5;
                if(dist(b, e) < e.radius + hitR) {
                    if (e.invulnerable) { b.life = 0; explode(b.x, b.y, '#fff', 1); }
                    else {
                        e.hp -= CONFIG.damage; b.life = 0;
                        if(e.hp <= 0) { 
                            e.marked = true; 
                            explode(e.x, e.y, e.color, 15, 6, 4, 0.03);
                        }
                    }
                }
            });
        });

        let threats = [...enemies, ...eBullets];
        if(boss) threats.push(boss);

        drones.forEach((d, idx) => {
            threats.forEach(t => {
                let r = t.radius || 5;
                if(dist(d.pos, t) < d.radius + r) {
                    drones.splice(idx, 1);
                    explode(d.pos.x, d.pos.y, '#00d2ff', 30, 8, 5, 0.02); 
                    game.shake = 8; 
                    if(t.vx) t.x = -1000; 
                }
            });
            powerups.forEach(p => {
                if(p.active && dist(d.pos, p) < d.radius + p.radius + 15) {
                    p.active = false;
                    drones.push(new Drone(d.pos.x, d.pos.y));
                    if(game.difficulty > 1.5) drones.push(new Drone(d.pos.x, d.pos.y));
                }
            });
        });

        bullets = bullets.filter(b => b.life > 0);
        eBullets = eBullets.filter(b => b.x > 0 && b.x < width);
        enemies = enemies.filter(e => !e.marked && e.x > -100);
        powerups = powerups.filter(p => p.active && p.x > -100);
        particles = particles.filter(p => p.life > 0);

        if(boss && boss.hp <= 0) {
            game.state = 'SCROLLING';
            boss = null;
            game.wave++;
            game.difficulty += 0.25;
            game.dist = 0;
            document.getElementById('boss-hud').style.display = 'none';
            for(let i=0; i<6; i++) drones.push(new Drone(width/2, height/2));
        }

        if (drones.length === 0 && game.state !== 'GAMEOVER' && game.state !== 'START') {
            gameOver();
        }
    }

    function loop() {
        if(window.innerWidth !== (canvas.clientWidth)) resize(); 

        let sx = 0, sy = 0;
        if(game.shake > 0) {
            sx = (Math.random()-0.5)*game.shake; sy = (Math.random()-0.5)*game.shake;
            game.shake *= 0.9; if(game.shake < 0.5) game.shake = 0;
        }

        ctx.save();
        ctx.translate(sx, sy);
        ctx.fillStyle = '#080808'; ctx.fillRect(-10, -10, width+20, height+20);

        // Update Game State
        if(game.state === 'SCROLLING') {
            game.dist += CONFIG.scrollSpeed;
            spawnSystem();
            let pct = Math.min(100, (game.dist / CONFIG.bossInterval) * 100);
            document.getElementById('progress-fill').style.width = pct + '%';
        }

        // Grid
        ctx.strokeStyle = 'rgba(30, 40, 50, 0.15)'; ctx.lineWidth = 1;
        let off = (Date.now() * -0.06) % 80;
        for(let x=off; x<width; x+=80) { ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,height); ctx.stroke(); }

        // Entities
        particles.forEach(p => { p.update(); p.draw(); });
        
        if (game.state !== 'START') {
            powerups.forEach(p => { 
                p.x -= CONFIG.scrollSpeed;
                ctx.beginPath(); ctx.arc(p.x, p.y, p.radius, 0, Math.PI*2); 
                ctx.fillStyle = '#00e676'; ctx.fill();
                ctx.shadowBlur = 10; ctx.shadowColor = '#00e676'; ctx.stroke(); ctx.shadowBlur = 0;
            });

            enemies.forEach(e => { e.update(); e.draw(); });
            if(boss) { boss.update(); boss.draw(); }

            ctx.fillStyle = '#ff1744';
            eBullets.forEach(b => {
                b.x += b.vx; b.y += b.vy;
                ctx.beginPath(); ctx.arc(b.x, b.y, b.radius, 0, Math.PI*2); ctx.fill();
            });

            ctx.strokeStyle = '#00ffff'; ctx.lineWidth = 3; ctx.shadowBlur = 10; ctx.shadowColor = '#00ffff';
            bullets.forEach(b => {
                b.x += b.vx + CONFIG.scrollSpeed*0.5; b.y += b.vy;
                b.life--;
                ctx.globalAlpha = (b.life < 10) ? b.life / 10 : 1.0;
                ctx.beginPath(); ctx.moveTo(b.x, b.y); ctx.lineTo(b.x - b.vx * 1.5, b.y - b.vy * 1.5); ctx.stroke();
            });
            ctx.globalAlpha = 1.0; ctx.shadowBlur = 0; ctx.lineWidth = 1;

            checkCollisions();
        }

        drones.forEach(d => { d.update(drones); d.draw(); });
        ctx.restore();

        // HUD
        document.getElementById('count').innerText = drones.length;
        document.getElementById('wave').innerText = game.wave;
        document.getElementById('haz-val').innerText = game.hazardRate + '%';
        if(boss) document.getElementById('boss-health').style.width = (boss.hp/boss.maxHp*100) + '%';

        requestAnimationFrame(loop);
    }

    // --- EVENTS ---
    document.getElementById('btn-start').addEventListener('click', () => {
        document.getElementById('start-screen').style.display = 'none';
        resetGame();
    });
    
    document.getElementById('btn-restart').addEventListener('click', () => {
        document.getElementById('game-over-screen').style.display = 'none';
        resetGame();
    });

    // Input
    window.addEventListener('mousemove', e => { mouse.x = e.clientX * scaleFactor; mouse.y = e.clientY * scaleFactor; });
    window.addEventListener('mousedown', () => mouse.down = true);
    window.addEventListener('mouseup', () => mouse.down = false);

    canvas.addEventListener('touchstart', e => {
        e.preventDefault(); mouse.down = true;
        mouse.x = e.touches[0].clientX * scaleFactor; mouse.y = e.touches[0].clientY * scaleFactor;
    }, {passive: false});
    canvas.addEventListener('touchmove', e => {
        e.preventDefault();
        mouse.x = e.touches[0].clientX * scaleFactor; mouse.y = e.touches[0].clientY * scaleFactor;
    }, {passive: false});
    canvas.addEventListener('touchend', e => { e.preventDefault(); mouse.down = false; }, {passive: false});

    resize();
    window.addEventListener('resize', resize);
    
    // Spawn Idle Drones for Title Screen
    for(let i=0; i<CONFIG.droneCount; i++) drones.push(new Drone(width/2, height/2));
    loop();

</script>
</body>
</html>
